# Day 1

Solving Club > list(7월 31일)

* 조망권 View
  * 소스보기 [소스보기](./1206.py)
  * best [소스보기](./1206풀이.py)



# Day 2

### SWEA

Lean > Course > IM > List1

* 1일차 - min max [소스보기](./4828.py)

* 1일차 - 전기버스 [소스보기](./4831.py)
  
  * 현재 위치가 N-K보다 작을 동안 반복 
  
  * 현재 위치 pos에서 갈 수 있는 만큼 최대한(pos+k) 간 후, 그 전에 위치한  가장 최근 정류장에서 충전
  
  * 운행할 수 없는 경우1:  현재 위치 pos에서 다음 충전기 정류장 pos+1까지 거리가 k보다 큰 경우
  
  * 운행할 수 없는 경우2: k*m이 n보다 작은경우
  
  * 정류장개수만큼 list. 충전기 있으면 1, 없으면 0. 정류장개수는 100이하. idx는 정류장위치.
  
  * error
  
    ```python
    for j in range(k, -1, -1): # => x
    for j in range(k, 0, -1): # k ~ 1까지
        
    # (n, m) => n ~ m-1
    # (m, n, -1) => m ~ n+1
    ```
  
* 1일차 - 숫자 카드 [소스보기](./4834.py)

  * 염겨레 방법

  ```python
  # 내코드
  ...      
  for i in range(1, 10):
      if cnt[i] >= max_cnt: # 더 개수가 크면
          max_cnt = cnt[i]
          max_num = i
  # 겨레코드 (좀 더 파이썬스러움)
  # list comprehension으로 0~9빈도수 리스트 채움
  ...
  # 최대값, 인덱스 구하는 코드
  max_cnt, max_num = (cnt[i], i) for i in range(1, 10) if cnt[i] >= max_cnt
  ```

* 1일차 - 구간합 [소스보기](./4835.py) 

  * 선생님 방법

  ```
  # 슬라이딩 윈도우
  A, B, C, D
  1회 합 : A+B+C
  2회 합 : B+C+D
  회차마다 더해주지 말고, 2회 때 1회합 - A + D
  시간복잡도 O(n)
  ```

Solving Club > list(8월 1일)

* Flatten, 평탄화 [소스보기](1208.py)

  * 인덱스 접근, 변수에 따로 저장해 접근 [소스보기](1208-2.py)

  ```python
  if box[i] > box[max_idx] # 비교할 때마다 인덱스로 접근하는 대신
  if box[i] > max_val # 변수에 저장하여 비교
  ```

  실행 결과 1.7~1.8 로 별 차이 없었음.

  * 내방법
  
  ```
  건물의 높이를 값으로 가지는 리스트.
  idx는 position
  최소값, 최대값 찾아 덤프 횟수만큼 평탄화
  ```
  
  * 염동환 방법
  
  ```
  높이 큰 것부터 빈도 세기 list 'up', idx = 개수(1 ~ 100)
  높이 작은 것부터 빈도 세기 
  덤프 수만큼 평탄화
  ```
  
  * 선생님 방법
  
  ```
  1. 빈도수 계산
  건물의 높이를 idx로 가지는 리스트. (0 ~ 100 값을 가짐)
  
  2. 최대 최소 찾기
  최소값은 idx = 0부터 처음으로 0이 아닌값을 갖는 idx
  최대값은 idx = 100부터 처음으로 0이 아닌 값을 찾는 idx
  
  3. 평탄화 작업
  최소값 빈도수 올리기, 최대값 빈도수 내리기
  ```
  
  

# Day 3

Solving Club > list(8월 7일)

* [2일차 - Sum 1209 소스보기](./code/1209.py)

  * input 값 100개씩 들어옴
  * 100 * 100 행렬
  * 1차원 리스트로 짜보기

  ```python
  # 1차원 리스트
  arr = []
  for _ in range(100):
      arr += list(map(int, input().split()))
      
  # 2차원 리스트
  arr = [list(map(int, input().split())) for _ in range(100)]
  ```

  * 1차원 리스트의 idx

  ```
  만약 2차원 배열 인덱스가 [67][8]이라면,
  1차원 배열 인덱스는 [67 * 100 + 8] 이다.
  ```
  
  * [1209풀이 - for문 한개 쓰기](./code/1209풀이.py)

[추가 문제 - 백준](https://www.acmicpc.net/problem/2578)

* [2578 빙고](./code/2578.py) (미완성코드)

* [요리사 4012](./code/4012.py) (아직 안함)

  * 부분집합 문제
  * 부분집합 잘 모르니 일단 그냥 풀어보기

  ```
  식재료를 2그룹으로 나누어야 된다.
  N개의 식재료 --> N/2, N/2
  => 조합 문제(부분집합과 관련)
  원소의 개수가 N/2인 부분집합 찾으면 1그룹 나머지는 2그룹으로.
  N = 최대 16 --> 2^16 = 65,000
  
  가지치기하면 좀 더 빠르게 풀 수 있다!
  ```
  
  * 선생님 풀이
  
  ```python
  # 중복 상관없이 그냥 하기
  
  arr = 'ABCD'
  N = 4
  
  for set_num in range(1 << N):
      a, b = [], []
      for i in range(N):
          if set_num & (1 << i):
              a.append(arr[i])
          else:
              b.append(arr[i])
     if len(a) == len(b):
      	print(a, b)
          
  # ['A', 'B'] ['C', 'D']
  # ...
  # ['C', 'D'] ['A', 'B']
  ```
  
  
  
  

# Day 4

Lean > Course > IM > List2

* [색칠하기 4836](./code/4836.py)

```python
# 칠해지지 않은 상태에서 처음 칠할 때만 쓸 수 있음
# 두번째 칠할 때 부터는 어떤색인지 확인해야 함!
# 밑에 코드 쓰지 않기!
for i in range(r1, r2+1): # 위 -> 아래로 r1~r2
    gird[i][c1:c2+1] = [color] * (c2-c1) # c1~c2 개수만큼 color 변경
    
# for문 2개로 row, col 순회하며 color 확인
```

* [부분집합의 합 4837](./code/4837.py)
* [이진탐색 4839](./code/4839.py)
* [특별한 정렬 4843](./code/4843.py)

Solving Club > list(8월 8일)

* [7일차 - 금속막대 1259](./code/1259.py)

  * 수나사, 암나사 길이가 같은 나사는 존재하지 않음!
  * 연결되지 않는 나사 존재하지 않음!
  * 그냥 끼워넣기로 풀어보기

  ```
  1. 시작 나사를 찾기
     수나사와 대응되는 암나사가 없으면 시작 나사!
  2. 나사를 list에 삽입하면서 마지막나사인 암나사와 대응되는 수나사를 찾는다!
  3. 2를 n-2번(시작나사 제외) 반복한다 
  ```
  
  * 장은비 방법(재귀로 구현)
  
  ```
  def sort(screws, result, tmp):
  
  screws : 나사
  result : 답으로 출력할 리스트
  tmp
  
  screws에 있는 나사를 한 개씩 읽음.
  연결이 되면 result
  연결이 안되면 tmp
  tmp + result
  
  return sort(tmp, result, [])
  ```
  
  * 선생님 방법
  
  ```
  순열 만드는 방법, 모든 방법 단순한 방법
  하나씩 연결하면서 안되면 가지치기
  순열 생성 아직 재귀로 하는 것 안 배움! 나중에 배우면 해보기!
  ```
  
  * SWEA 화학물질2 비슷한 문제 풀어보기! 순열, DP

추가 문제 - 백준

 * [색종이 10163](./code/10163.py)
   
    * [사이트](https://www.acmicpc.net/problem/10163)
    
 * [숫자카드 10815](./code/10815.py) (미완성)
   
   * [사이트](https://www.acmicpc.net/problem/10815)
   * 첫번째시도) 초기 완전탐색 코드 시간초과!
   * 두번째시도) 이진 탐색
     * 상근이 카드 정렬 시킨 후 할 것
     * 이 때, sorted() 써도 되는지.. 모르겠지만 일단 써보자.
   * 김태우 방법(set 이용)
   
   ```
   상근 카드 set
   검사할 카드 list
   
   set은 이진탐색트리, 해싱으로 구현되어 있음
   map, set, hashmap, hashset 등..
   
   주의) set은 순서를 보장하지 않음! indexing x
   ```
   

# Day 5

SWEA

* [String 1221.py](./code/1221.py)
  * 내 방법은 dictionary에 개수 세어 저장하고 출력하는 방식.
  * 굳이 이렇게 할 이유가 없음
  * 세면서 바로 출력하게 하기!
* [간단한 압축 풀기 1946.py](./code/1946.py)

# Day 6

SWEA > Learn > Course > IM > 파이썬 - String

* [문자열 비교 4864.py](./code/4864.py)
  * 브루트 포스로 풀어보자.
  * 다른 방법으로도 풀어보기!
  
* [회문 4861.py](./code/4861.py) 

  * 추윤형 코드 [4861chu.py](./code/4861chu.py)

  ```
  이중 for문 나오기 위해 flag 라는 변수를 이용!
  ```

  * 정지수 코드

  ```
  한 함수로 가로, 세로 검사 모두 가능하도록 함!
  지금 나의 방법은 가로, 세로 검사 따로 함수를 만들었음
  행,열 바꾸기를 이용함
  
  데이터가 크지 않을 경우,
  이 방법이 더 좋다고 함!
  ```

  

* [글자수 4865.py](./code/4865.py)

추가문제

* [세상의 모든 팰린드롬 2 4579.py](./code/4579.py)
* [세상의 모든 팰린드롬 4522.py](./code/4522.py)
* [자기 방으로 돌아가기 4408.py](./code/4408.py)

Solving club > 03.String(8월 16일)

* [회문2 1216.py](./code/1216.py) 아직 안함

* [회문2 1215.py](./code/1215.py) 

  ```
  index 주의하기!
  가장 많이 뜬 에러 out of range index
  
  윤형씨 팁)
  인덱스 에러가 뜰 때 마지막 범위 + 1 해보고 돌려보기
  
  검사 범위 (text길이8, 회문길이4 일 때)
  행 검사: row는 0 ~ 7 / col은 0 ~ 4
  열 검사: col은 0 ~ 7 / row는 0 ~ 4
  ```

  